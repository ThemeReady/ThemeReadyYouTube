.class final Lokg;
.super Ljava/lang/Object;
.source "SourceFile"

# interfaces
.implements Lokr;


# instance fields
.field public a:Llfu;

.field public b:Llkk;

.field public c:Llkw;

.field public d:Llhp;

.field public e:Lljr;

.field public f:Llpj;

.field public g:Lloq;

.field public h:Llof;

.field public i:Lleo;

.field public j:Loln;

.field public k:Llir;

.field public l:Llmp;

.field public m:Lldq;

.field public n:Lldl;

.field public o:Lllr;

.field public p:Llhf;

.field public q:Llhy;

.field public r:Llni;

.field public s:Lloj;

.field public t:Loko;


# direct methods
.method constructor <init>()V
    .locals 0

    .prologue
    .line 1
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method


# virtual methods
.method public final synthetic a(Loko;)Lokr;
    .locals 1

    .prologue
    .line 47
    invoke-static {p1}, Laeai;->a(Ljava/lang/Object;)Ljava/lang/Object;

    move-result-object v0

    check-cast v0, Loko;

    iput-object v0, p0, Lokg;->t:Loko;

    .line 49
    return-object p0
.end method

.method public final synthetic a()Loks;
    .locals 3

    .prologue
    .line 3
    iget-object v0, p0, Lokg;->a:Llfu;

    if-nez v0, :cond_0

    .line 4
    new-instance v0, Llfu;

    invoke-direct {v0}, Llfu;-><init>()V

    iput-object v0, p0, Lokg;->a:Llfu;

    .line 5
    :cond_0
    iget-object v0, p0, Lokg;->b:Llkk;

    if-nez v0, :cond_1

    .line 6
    new-instance v0, Llkk;

    invoke-direct {v0}, Llkk;-><init>()V

    iput-object v0, p0, Lokg;->b:Llkk;

    .line 7
    :cond_1
    iget-object v0, p0, Lokg;->c:Llkw;

    if-nez v0, :cond_2

    .line 8
    new-instance v0, Llkw;

    invoke-direct {v0}, Llkw;-><init>()V

    iput-object v0, p0, Lokg;->c:Llkw;

    .line 9
    :cond_2
    iget-object v0, p0, Lokg;->d:Llhp;

    if-nez v0, :cond_3

    .line 10
    new-instance v0, Llhp;

    invoke-direct {v0}, Llhp;-><init>()V

    iput-object v0, p0, Lokg;->d:Llhp;

    .line 11
    :cond_3
    iget-object v0, p0, Lokg;->e:Lljr;

    if-nez v0, :cond_4

    .line 12
    new-instance v0, Lljr;

    invoke-direct {v0}, Lljr;-><init>()V

    iput-object v0, p0, Lokg;->e:Lljr;

    .line 13
    :cond_4
    iget-object v0, p0, Lokg;->f:Llpj;

    if-nez v0, :cond_5

    .line 14
    new-instance v0, Llpj;

    invoke-direct {v0}, Llpj;-><init>()V

    iput-object v0, p0, Lokg;->f:Llpj;

    .line 15
    :cond_5
    iget-object v0, p0, Lokg;->g:Lloq;

    if-nez v0, :cond_6

    .line 16
    new-instance v0, Lloq;

    invoke-direct {v0}, Lloq;-><init>()V

    iput-object v0, p0, Lokg;->g:Lloq;

    .line 17
    :cond_6
    iget-object v0, p0, Lokg;->h:Llof;

    if-nez v0, :cond_7

    .line 18
    new-instance v0, Llof;

    invoke-direct {v0}, Llof;-><init>()V

    iput-object v0, p0, Lokg;->h:Llof;

    .line 19
    :cond_7
    iget-object v0, p0, Lokg;->i:Lleo;

    if-nez v0, :cond_8

    .line 20
    new-instance v0, Lleo;

    invoke-direct {v0}, Lleo;-><init>()V

    iput-object v0, p0, Lokg;->i:Lleo;

    .line 21
    :cond_8
    iget-object v0, p0, Lokg;->j:Loln;

    if-nez v0, :cond_9

    .line 22
    new-instance v0, Loln;

    invoke-direct {v0}, Loln;-><init>()V

    iput-object v0, p0, Lokg;->j:Loln;

    .line 23
    :cond_9
    iget-object v0, p0, Lokg;->k:Llir;

    if-nez v0, :cond_a

    .line 24
    new-instance v0, Llir;

    invoke-direct {v0}, Llir;-><init>()V

    iput-object v0, p0, Lokg;->k:Llir;

    .line 25
    :cond_a
    iget-object v0, p0, Lokg;->l:Llmp;

    if-nez v0, :cond_b

    .line 26
    new-instance v0, Llmp;

    invoke-direct {v0}, Llmp;-><init>()V

    iput-object v0, p0, Lokg;->l:Llmp;

    .line 27
    :cond_b
    iget-object v0, p0, Lokg;->m:Lldq;

    if-nez v0, :cond_c

    .line 28
    new-instance v0, Lldq;

    invoke-direct {v0}, Lldq;-><init>()V

    iput-object v0, p0, Lokg;->m:Lldq;

    .line 29
    :cond_c
    iget-object v0, p0, Lokg;->n:Lldl;

    if-nez v0, :cond_d

    .line 30
    new-instance v0, Lldl;

    invoke-direct {v0}, Lldl;-><init>()V

    iput-object v0, p0, Lokg;->n:Lldl;

    .line 31
    :cond_d
    iget-object v0, p0, Lokg;->o:Lllr;

    if-nez v0, :cond_e

    .line 32
    new-instance v0, Lllr;

    invoke-direct {v0}, Lllr;-><init>()V

    iput-object v0, p0, Lokg;->o:Lllr;

    .line 33
    :cond_e
    iget-object v0, p0, Lokg;->p:Llhf;

    if-nez v0, :cond_f

    .line 34
    new-instance v0, Llhf;

    invoke-direct {v0}, Llhf;-><init>()V

    iput-object v0, p0, Lokg;->p:Llhf;

    .line 35
    :cond_f
    iget-object v0, p0, Lokg;->q:Llhy;

    if-nez v0, :cond_10

    .line 36
    new-instance v0, Llhy;

    invoke-direct {v0}, Llhy;-><init>()V

    iput-object v0, p0, Lokg;->q:Llhy;

    .line 37
    :cond_10
    iget-object v0, p0, Lokg;->r:Llni;

    if-nez v0, :cond_11

    .line 38
    new-instance v0, Llni;

    invoke-direct {v0}, Llni;-><init>()V

    iput-object v0, p0, Lokg;->r:Llni;

    .line 39
    :cond_11
    iget-object v0, p0, Lokg;->s:Lloj;

    if-nez v0, :cond_12

    .line 40
    new-instance v0, Lloj;

    invoke-direct {v0}, Lloj;-><init>()V

    iput-object v0, p0, Lokg;->s:Lloj;

    .line 41
    :cond_12
    iget-object v0, p0, Lokg;->t:Loko;

    if-nez v0, :cond_13

    .line 42
    new-instance v0, Ljava/lang/IllegalStateException;

    const-class v1, Loko;

    invoke-virtual {v1}, Ljava/lang/Class;->getCanonicalName()Ljava/lang/String;

    move-result-object v1

    invoke-static {v1}, Ljava/lang/String;->valueOf(Ljava/lang/Object;)Ljava/lang/String;

    move-result-object v1

    const-string v2, " must be set"

    invoke-virtual {v1, v2}, Ljava/lang/String;->concat(Ljava/lang/String;)Ljava/lang/String;

    move-result-object v1

    invoke-direct {v0, v1}, Ljava/lang/IllegalStateException;-><init>(Ljava/lang/String;)V

    throw v0

    .line 43
    :cond_13
    new-instance v0, Lokf;

    .line 44
    invoke-direct {v0, p0}, Lokf;-><init>(Lokg;)V

    .line 45
    return-object v0
.end method
